'use strict';

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

/**
 * Hook handles manually setting some additional attributes on the video that
 * can't be set directly via attributes on the element.
 *
 * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element
 * @param {bool} muted - Whether the video should be muted
 * @param {number} volume - The volume level that the video's audio should be set to
 * @param {bool} disableRemotePlayback - Whether we want to disable showing controls to cast the video
 * @param {bool} disablePictureInPicture - Whether we want to disable showing controls to play the video in picture-in-picture mode
 */
function useSetAdditionalAttributesOnVideo(videoRef, muted, volume, disableRemotePlayback, disablePictureInPicture) {
    React.useEffect(function () {
        var videoElement = videoRef.current;
        // Manually setting the `muted` attribute on the video element via an effect in order
        // to avoid a know React issue with the `muted` prop not applying correctly on initial render
        // https://github.com/facebook/react/issues/10389
        videoElement.muted = muted;
        // Set the video's volume to match the `volume` prop
        // Note that this will have no effect if the `muted` prop is set to true
        videoElement.volume = volume;
    }, [videoRef, muted, volume]);
    React.useEffect(function () {
        var videoElement = videoRef.current;
        // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly
        // via the video element's props, so we have to manually set them in an effect
        videoElement.disableRemotePlayback = disableRemotePlayback;
        videoElement.disablePictureInPicture = disablePictureInPicture;
    }, [videoRef, disablePictureInPicture, disableRemotePlayback]);
}

/**
 * Hook adds event listeners to the hover target and returns whether the user is currently hovering over it or not.
 *
 * @param {HoverTarget} hoverTarget - Ref, function, or Node for the element that we should apply our hover event listeners to.
 *                                      If the user did not specify one with the hoverTarget prop, we will fall back to use
 *                                      the hover player's container div element.
 * @param {bool} disableDefaultEventHandling - Whether our default event handling should be disabled.
 * @param {func} onHoverStart - Callback fired when the user starts hovering on the player's hover target
 * @param {func} onHoverEnd - Callback fired when the user stops hovering on the player's hover target
 *
 * @returns {bool}  Whether the user is currently hovering over the player's hover target
 */
function useIsHoveringOverVideo(hoverTarget, disableDefaultEventHandling, onHoverStartCallback, onHoverEndCallback) {
    // Keep track of whether the user is hovering over the video and it should therefore be playing or not
    var _a = React.useState(false), isHoveringOverVideo = _a[0], setIsHoveringOverVideo = _a[1];
    var previousIsHoveringOverVideoRef = React.useRef(isHoveringOverVideo);
    React.useEffect(function () {
        // If default event handling is disabled, we shouldn't check for touch events outside of the player
        if (disableDefaultEventHandling)
            return undefined;
        // Get the element that we should add our hover event listeners to
        var hoverEventTargetElement;
        // If the `hoverTarget` prop was provided, it could be a function, a DOM element, or a React ref, so
        // figure out which one it is and get the hover target element out of it accordingly
        if (typeof hoverTarget === 'function') {
            hoverEventTargetElement = hoverTarget();
        }
        else if (hoverTarget instanceof Node) {
            hoverEventTargetElement = hoverTarget;
        }
        else if (hoverTarget.current) {
            hoverEventTargetElement = hoverTarget.current;
        }
        // If we weren't able to get a valid hover target to attach event listeners to, return early
        if (!hoverEventTargetElement || !hoverEventTargetElement.addEventListener) {
            console.error('HoverVideoPlayer was unable to add event listeners to a hover target. Please check your usage of the `hoverTarget` prop.');
            return undefined;
        }
        // Add the event listeners
        var onHoverStart = function () { return setIsHoveringOverVideo(true); };
        var onHoverEnd = function () { return setIsHoveringOverVideo(false); };
        // Mouse events
        hoverEventTargetElement.addEventListener('mouseenter', onHoverStart);
        hoverEventTargetElement.addEventListener('mouseleave', onHoverEnd);
        // Focus/blur
        hoverEventTargetElement.addEventListener('focus', onHoverStart);
        hoverEventTargetElement.addEventListener('blur', onHoverEnd);
        // Touch events
        var touchStartListenerOptions = { passive: true };
        hoverEventTargetElement.addEventListener('touchstart', onHoverStart, touchStartListenerOptions);
        // Event listener pauses the video when the user touches somewhere outside of the player
        var onWindowTouchStart = function (event) {
            if (!(event.target instanceof Node) ||
                !hoverEventTargetElement.contains(event.target)) {
                onHoverEnd();
            }
        };
        window.addEventListener('touchstart', onWindowTouchStart, touchStartListenerOptions);
        // Return a cleanup function that removes all event listeners
        return function () {
            hoverEventTargetElement.removeEventListener('mouseenter', onHoverStart);
            hoverEventTargetElement.removeEventListener('mouseleave', onHoverEnd);
            hoverEventTargetElement.removeEventListener('focus', onHoverStart);
            hoverEventTargetElement.removeEventListener('blur', onHoverEnd);
            hoverEventTargetElement.removeEventListener('touchstart', onHoverStart);
            window.removeEventListener('touchstart', onWindowTouchStart);
        };
    }, [disableDefaultEventHandling, hoverTarget]);
    // Effect fires hover callbacks as isHoveringOverVideo changes
    React.useEffect(function () {
        if (previousIsHoveringOverVideoRef.current === isHoveringOverVideo)
            return;
        previousIsHoveringOverVideoRef.current = isHoveringOverVideo;
        if (isHoveringOverVideo && onHoverStartCallback != null) {
            onHoverStartCallback();
        }
        else if (!isHoveringOverVideo && onHoverEndCallback != null) {
            onHoverEndCallback();
        }
    }, [isHoveringOverVideo, onHoverEndCallback, onHoverStartCallback]);
    return isHoveringOverVideo;
}

// Enumerates states that the hover player's overlay can be in
var OverlayState;
(function (OverlayState) {
    // Only the paused overlay is visible, if provided
    OverlayState["paused"] = "paused";
    // Both the paused and loading overlays are visible, if provided
    OverlayState["loading"] = "loading";
    // No overlays are visible
    OverlayState["playing"] = "playing";
})(OverlayState || (OverlayState = {}));

/**
 * Hook manages safely transitioning video playback between
 * a playing or paused state, depending on the value of shouldPlayVideo
 *
 * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element
 * @param {bool} shouldPlayVideo - Whether the video should currently be playing or not
 * @param {number} playbackRangeStart - The start time of the playback range that the video must be kept within
 * @param {number} playbackRangeEnd - The end time of the playback range that the video must be kept within
 * @param {bool} loop - Whether the video should loop when it reaches the end of its playback range or not
 *                        If a playback range is set, the native `loop` video attribute will not work, so we have to
 *                        manually implement this behavior ourselves.
 * @param {bool} restartOnPaused - Whether the video should be reset to the start when paused
 * @param {bool} shouldWaitForOverlayTransitionBeforePausing - Whether the player has an overlay which we should wait to fade back in before we pause the video
 * @param {bool} hasLoadingOverlay - Whether the player has an overlay to display when loading
 * @param {number} overlayTransitionDuration - How long it should take for overlays to fade in/out; this influences how long we should wait
 *                                              after the user stops hovering before fully pausing the video since the paused overlay needs time to fade in.
 * @param {number} loadingStateTimeout - How long to wait after starting a play attempt to fade in the loading overlay
 *
 * @returns {[OverlayState, bool]} An array with the current overlay state in the first position and whether the video player is active in the second positions
 */
function useManageVideoPlayback(videoRef, shouldPlayVideo, playbackRangeStart, playbackRangeEnd, loop, restartOnPaused, shouldWaitForOverlayTransitionBeforePausing, hasLoadingOverlay, overlayTransitionDuration, loadingStateTimeout) {
    // Keep track of how the paused and loading overlays should be displayed
    var _a = React.useState(OverlayState.paused), overlayState = _a[0], setOverlayState = _a[1];
    // Keep track of whether the video is currently playing or attempting to play
    var _b = React.useState(false), isVideoLoadingOrPlaying = _b[0], setIsVideoLoadingOrPlaying = _b[1];
    // Keep track of when the video is "active", meaning it is in one of the following states:
    // 1. The user is hovering over the video but it is still loading
    // 2. The user is hovering over the video and it is playing
    // 3. The user is no longer hovering over the video but it is still transitioning back into a paused state
    //
    // This helps us keep track of when the player is truly done with the video so we can perform
    // cleanup such as resetting the time to the start or unloading the video
    var isVideoActive = shouldPlayVideo || isVideoLoadingOrPlaying;
    // Keep a ref for all variables related to the video's playback state
    // which we need to persist between renders and manage asynchronously
    // but shouldn't trigger re-renders when updated
    var mutableVideoState = React.useRef(null);
    if (mutableVideoState.current === null) {
        // Set initial values for our video state
        mutableVideoState.current = {
            // Whether there is a play promise in progress which we should avoid interrupting
            // with calls to video.play() or video.load()
            isPlayAttemptInProgress: false,
            // Keep refs for timeouts so we can keep track of and cancel them
            pauseTimeout: null,
            loadingStateTimeout: null,
            // Keep track of the video time that we should start from when the video is played again
            // This is particularly useful so we can restore our previous place in the video even if
            // we are unloading it every time it gets paused
            videoTimeToRestore: playbackRangeStart || 0,
            // Keep refs to previous values for some states so we can avoid running effects for
            // changes in values we don't care about
            previousIsVideoActive: false,
            previousShouldPlayVideo: false,
        };
    }
    // Cancel any pending timeouts to pause or show a loading state
    var clearVideoStateTimeouts = React.useCallback(function () {
        clearTimeout(mutableVideoState.current.pauseTimeout);
        clearTimeout(mutableVideoState.current.loadingStateTimeout);
    }, []);
    React.useEffect(
    // On cleanup when the component is unmounting, clear any outstanding timeouts
    function () { return function () { return clearVideoStateTimeouts(); }; }, [clearVideoStateTimeouts]);
    // Method begins an attempt to play the video and updates state accordingly
    var attemptToPlayVideo = React.useCallback(function () {
        mutableVideoState.current.isPlayAttemptInProgress = true;
        videoRef.current.play();
    }, [videoRef]);
    // Method attempts to pause the video, if it is safe to do so without interrupting a pending play promise
    var attemptToPauseVideo = React.useCallback(function () {
        var videoElement = videoRef.current;
        if (!videoElement.paused &&
            // If there is a play attempt in progress, the video can't be
            //  safely paused right away without intnerrupting the play promise and throwing an error.
            // In this case, we'll have to wait for the logic in the video's `onPlaying` event
            // to immediately pause the video as soon as the play promise resolves
            !mutableVideoState.current.isPlayAttemptInProgress) {
            videoElement.pause();
        }
    }, [videoRef]);
    // Effect adds a `play` and `pause` event listener to the video element to keep our state
    // updated to reflect whether the video is currently playing or paused
    React.useEffect(function () {
        var videoElement = videoRef.current;
        var onPause = function () { return setIsVideoLoadingOrPlaying(false); };
        var onPlay = function () { return setIsVideoLoadingOrPlaying(true); };
        videoElement.addEventListener('pause', onPause);
        videoElement.addEventListener('play', onPlay);
        return function () {
            videoElement.removeEventListener('pause', onPause);
            videoElement.removeEventListener('play', onPlay);
        };
    }, [videoRef]);
    // Effect adds a `playing` event listener to the video to update state to reflect when the video successfully starts playing
    React.useEffect(function () {
        var videoElement = videoRef.current;
        // Listen for when the video actually finishes loading and starts playing
        var onPlaying = function () {
            // Ensure we cancel any pending loading state timeout
            clearVideoStateTimeouts();
            // The play attempt is now complete
            mutableVideoState.current.isPlayAttemptInProgress = false;
            if (shouldPlayVideo) {
                // Hide the overlays to reveal the video now that it's playing
                setOverlayState(OverlayState.playing);
            }
            else {
                // If the play attempt just succeeded but we no longer want to play the video,
                // pause it immediately!
                videoElement.pause();
            }
        };
        videoElement.addEventListener('playing', onPlaying);
        return function () {
            videoElement.removeEventListener('playing', onPlaying);
        };
    }, [clearVideoStateTimeouts, shouldPlayVideo, videoRef]);
    // When the video becomes inactive, effect resets it to the start if restartOnPaused is true and
    // stores the video's current time so we can restore to it when we start playing the video again
    React.useEffect(function () {
        if (mutableVideoState.current.previousIsVideoActive === isVideoActive) {
            return;
        }
        mutableVideoState.current.previousIsVideoActive = isVideoActive;
        if (!isVideoActive) {
            var videoElement = videoRef.current;
            // Ensure we cancel any pending timeouts to pause or show a loading state
            // since we are now officially paused
            clearVideoStateTimeouts();
            if (restartOnPaused) {
                // Reset the video to the start since we're now paused
                var resetStartTime = playbackRangeStart || 0;
                videoElement.currentTime = resetStartTime;
            }
            // Hang onto the time that the video is currently at so we can
            // restore it when we try to play again
            // This is mainly helpful because the unloadVideoOnPaused prop will cause
            // the video's currentTime to be cleared every time its sources are unloaded
            // after pausing
            mutableVideoState.current.videoTimeToRestore = videoElement.currentTime;
        }
    }, [
        clearVideoStateTimeouts,
        isVideoActive,
        playbackRangeStart,
        restartOnPaused,
        videoRef,
    ]);
    // Effect adds a `timeupdate` event listener to the video if a playback range is set to ensure
    // the video stays within the bounds of its playback range
    React.useEffect(function () {
        if (
        // If we don't have a playback range set, we don't need to do anything here
        playbackRangeStart === null &&
            playbackRangeEnd === null)
            return undefined;
        var videoElement = videoRef.current;
        // Makes sure the video stays clamped inside the playback range as its time updates
        var onTimeUpdate = function () {
            // Use playbackRangeEnd as our maximum time to play to, or default to the video's full duration
            var playbackRangeMaxTime = playbackRangeEnd || videoElement.duration;
            // Use playbackRangeStart as our minimum time to play from, or default to the very beginning of the video (0sƒ)
            var playbackRangeMinTime = playbackRangeStart || 0;
            if (videoElement.currentTime >= playbackRangeMaxTime) {
                // If the video's current time has played past the maximum time in the playback range,
                // determine how to handle keeping the video inside of the playback range
                if (loop) {
                    // If the video should loop, jump it back to the start of the playback range again
                    videoElement.currentTime = playbackRangeMinTime;
                    // If the video is paused, start playing it again (when the video reaches the end
                    // of the playback range for the first time, most browsers will pause it)
                    if (shouldPlayVideo && videoElement.paused) {
                        attemptToPlayVideo();
                    }
                }
                else {
                    // If we don't want to loop the video, just pause it
                    attemptToPauseVideo();
                    if (videoElement.currentTime > playbackRangeMaxTime) {
                        videoElement.currentTime = playbackRangeMaxTime;
                    }
                }
            }
            else if (videoElement.currentTime < playbackRangeMinTime) {
                // If the video's current time has someone gotten before the playback range,
                // clamp it to the lower end of the playback range
                videoElement.currentTime = playbackRangeMinTime;
            }
        };
        videoElement.addEventListener('timeupdate', onTimeUpdate);
        return function () {
            videoElement.removeEventListener('timeupdate', onTimeUpdate);
        };
    }, [
        attemptToPauseVideo,
        attemptToPlayVideo,
        loop,
        playbackRangeEnd,
        playbackRangeStart,
        shouldPlayVideo,
        videoRef,
    ]);
    // Effect attempts to play or pause the video as shouldPlayVideo changes
    React.useEffect(function () {
        // Only run the effect when shouldPlayVideo changes
        if (mutableVideoState.current.previousShouldPlayVideo === shouldPlayVideo) {
            return;
        }
        mutableVideoState.current.previousShouldPlayVideo = shouldPlayVideo;
        // Clear any outstanding timeouts since our playback state is changing
        clearVideoStateTimeouts();
        var videoElement = videoRef.current;
        // The video is stopped if it is paused or ended
        var isVideoStopped = videoElement.paused || videoElement.ended;
        // If shouldPlayVideo is true, attempt to start playing the video
        if (shouldPlayVideo) {
            // readyState 3 is HAVE_FUTURE_DATA, meaning the video has loaded enough data that it can play
            var isVideoLoadedEnoughToPlay = videoElement.readyState >= 3;
            // If the video is stopped or still loading and we have a loading overlay,
            // set a timeout to display the overlay if the video doesn't finish loading
            // after a certain amount of time
            if ((isVideoStopped || !isVideoLoadedEnoughToPlay) && hasLoadingOverlay) {
                // If we have a loading overlay, set a timeout to start showing it if the video doesn't start playing
                // before the loading state timeout has elapsed
                mutableVideoState.current.loadingStateTimeout = window.setTimeout(function () {
                    // If this timeout wasn't cancelled, we're still trying to play the video
                    // and it's still loading, so fade in the loading overlay
                    setOverlayState(OverlayState.loading);
                }, loadingStateTimeout);
            }
            // If the video is fully stopped, we need to attempt to start it by calling play()
            if (isVideoStopped) {
                // Ensure we're at the correct time to start playing from
                videoElement.currentTime = mutableVideoState.current.videoTimeToRestore;
                // Start attempting to play
                attemptToPlayVideo();
            }
            else if (isVideoLoadedEnoughToPlay) {
                // If the video isn't stopped and is loaded enough to play. it's already playing,
                // so ensure the overlays are hidden to reflect that!
                setOverlayState(OverlayState.playing);
            }
        }
        // Otherwise if shouldPlayVideo is false, go through the process necessary to pause the video
        else {
            // Start fading the paused overlay back in
            setOverlayState(OverlayState.paused);
            if (shouldWaitForOverlayTransitionBeforePausing &&
                overlayTransitionDuration) {
                // If we have a paused/hover overlay, set a timeout with a duration of the overlay's fade
                // transition since we want to keep the video playing until the overlay has fully
                // faded in and hidden it.
                mutableVideoState.current.pauseTimeout = window.setTimeout(attemptToPauseVideo, overlayTransitionDuration);
            }
            else {
                // If we don't have an overlay transition to wait on, pause right away!
                attemptToPauseVideo();
            }
        }
    }, [
        attemptToPauseVideo,
        attemptToPlayVideo,
        clearVideoStateTimeouts,
        hasLoadingOverlay,
        shouldWaitForOverlayTransitionBeforePausing,
        loadingStateTimeout,
        overlayTransitionDuration,
        shouldPlayVideo,
        videoRef,
    ]);
    return [overlayState, isVideoActive];
}

/**
 * Hook unloads the video when it is paused, if the unloadVideoOnPaused prop was set to true
 *
 * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element
 * @param {bool} shouldUnloadVideo - Whether we should unload the video's sources
 */
function useUnloadVideo(videoRef, shouldUnloadVideo) {
    // Effect ensures the video element fully unloads after its <source> tags were removed
    React.useEffect(function () {
        if (shouldUnloadVideo) {
            // Perform a manual load to unload the video's current source
            var videoElement = videoRef.current;
            videoElement.load();
        }
    }, [shouldUnloadVideo, videoRef]);
}

/**
 * @function  formatVideoSrc
 *
 * Hook takes the videoSrc prop and formats it as a standardized array of VideoSource objects which can be used to render
 * <source> elements for the video
 *
 * @param {VideoSrcProp}  videoSrc - Source(s) to format into VideoSource objects so they can be added to the video player.
 * @param {number}  playbackRangeStart - The earliest time in seconds that we should start loading the video from.
 *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only
 *                                        load the video starting from this time.
 *                                        If not provided, we will load from the start of the video.
 * @param {number}  playbackRangeEnd - The maximum time in seconds that we should load the video to.
 *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only
 *                                        load the video up to this time.
 *                                        If not provided, we will load to the end of the video.
 *
 * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video
 */
function useFormatVideoSrc(videoSrc, playbackRangeStart, playbackRangeEnd) {
    return React.useMemo(function () {
        var formattedVideoSources = [];
        if (videoSrc == null) {
            // A videoSrc value is required in order to make the video player work
            console.error("Error: 'videoSrc' prop is required for HoverVideoPlayer component");
        }
        else {
            // Make sure we can treat the videoSrc value as an array
            var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc];
            // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video
            for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {
                var source = rawVideoSources[i];
                var hasPlaybackRangeStart = playbackRangeStart !== null;
                var hasPlaybackRangeEnd = playbackRangeEnd !== null;
                // Construct a media fragment identifier string to append to the video's URL to ensure
                // we only load the portion of the video that we need for the provided playback range
                // (see here for more details: https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery#specifying_playback_range)
                var playbackRangeMediaFragmentIdentifier = hasPlaybackRangeStart || hasPlaybackRangeEnd
                    ? // If we have a playback range defined, construct a #t media fragment identifier string
                        // This identifier follows the format `#t=[starttime][,endtime]` and will tell the browser to only load the video file
                        // within this defined time range.
                        // This helps save us from loading some unneeded data when we only need whatever is within the playback range!
                        "#t=" + (hasPlaybackRangeStart ? playbackRangeStart : '') + (hasPlaybackRangeEnd ? "," + playbackRangeEnd : '')
                    : '';
                if (typeof source === 'string') {
                    // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array
                    formattedVideoSources.push({
                        src: "" + source + playbackRangeMediaFragmentIdentifier,
                    });
                }
                else if (source && source.src) {
                    // If the source is an object with an src, just add it to the array
                    formattedVideoSources.push({
                        src: "" + source.src + playbackRangeMediaFragmentIdentifier,
                        type: source.type,
                    });
                }
                else {
                    // Log an error if one of the videoSrc values is invalid
                    console.error("Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':", source);
                }
            }
        }
        return formattedVideoSources;
    }, [videoSrc, playbackRangeStart, playbackRangeEnd]);
}

/**
 * Hook takes the videoCaptions prop and formats it as a standardized array of VideoCaptionsTrack objects which can be used to render
 * <track> elements for the video
 *
 * @param {VideoCaptionsProp} videoCaptions - Captions track(s) to use for the video player for accessibility.
 *
 * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video
 */
function useFormatVideoCaptions(videoCaptions) {
    return React.useMemo(function () {
        var formattedVideoCaptions = [];
        // If captions were provided, format them for use for the video
        if (videoCaptions != null) {
            // Make sure we can treat the videoCaptions value as an array
            var rawVideoCaptions = Array.isArray(videoCaptions)
                ? videoCaptions
                : [videoCaptions];
            // Parse our raw video captions values into an array of formatted VideoCaptionsTrack
            // objects that can be used to render caption tracks for the video
            for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {
                var captions = rawVideoCaptions[i];
                if (captions && captions.src) {
                    formattedVideoCaptions.push({
                        src: captions.src,
                        srcLang: captions.srcLang,
                        label: captions.label,
                        kind: captions.kind || 'captions',
                        default: Boolean(captions.default),
                    });
                }
                else {
                    // Log an error if one of the videoCaptions values is invalid
                    console.error("Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'", captions);
                }
            }
        }
        return formattedVideoCaptions;
    }, [videoCaptions]);
}

// CSS styles to make some contents in the player expand to fill the container
var expandToFillContainerStyle = {
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
};
var containerMatchContentDimensionsStyle = {
    display: 'inline-block',
};
var containerSizingStyles = {
    video: containerMatchContentDimensionsStyle,
    overlay: containerMatchContentDimensionsStyle,
    container: null,
    manual: null,
};
// Styles to apply to the paused overlay wrapper for each sizing mode
var pausedOverlayWrapperSizingStyles = {
    // Sizing should be based on the video element, so make the overlay
    // expand to cover the player's container element
    video: expandToFillContainerStyle,
    // Sizing should be based on the paused overlay, so set position: relative
    // to make it occupy space in the document flow
    overlay: {
        position: 'relative',
    },
    // Sizing should be based on the player's container element, so make the overlay
    // expand to cover it
    container: expandToFillContainerStyle,
    // Don't apply any preset styling to the overlay
    manual: null,
};
// Styles to apply to the video element for each sizing mode
var videoSizingStyles = {
    // Sizing should be based on the video element, so set display: block
    // to make sure it occupies space in the document flow
    video: {
        display: 'block',
        // Ensure the video is sized relative to the container's width
        // rather than the video asset's native width
        width: '100%',
    },
    // Make the video element expand to cover the container if we're sizing
    // based on the overlay or container
    overlay: expandToFillContainerStyle,
    container: expandToFillContainerStyle,
    // Don't apply any preset styling to the video
    manual: null,
};

/**
 * @component HoverVideoPlayer
 * @license MIT
 *
 * @param {HoverVideoPlayerProps} props
 */
var HoverVideoPlayer = function (_a) {
    var videoSrc = _a.videoSrc, _b = _a.videoCaptions, videoCaptions = _b === void 0 ? null : _b, _c = _a.focused, focused = _c === void 0 ? false : _c, _d = _a.disableDefaultEventHandling, disableDefaultEventHandling = _d === void 0 ? false : _d, _e = _a.hoverTarget, hoverTarget = _e === void 0 ? null : _e, _f = _a.onHoverStart, onHoverStart = _f === void 0 ? null : _f, _g = _a.onHoverEnd, onHoverEnd = _g === void 0 ? null : _g, _h = _a.hoverOverlay, hoverOverlay = _h === void 0 ? null : _h, _j = _a.pausedOverlay, pausedOverlay = _j === void 0 ? null : _j, _k = _a.loadingOverlay, loadingOverlay = _k === void 0 ? null : _k, _l = _a.loadingStateTimeout, loadingStateTimeout = _l === void 0 ? 200 : _l, _m = _a.overlayTransitionDuration, overlayTransitionDuration = _m === void 0 ? 400 : _m, _o = _a.restartOnPaused, restartOnPaused = _o === void 0 ? false : _o, _p = _a.unloadVideoOnPaused, unloadVideoOnPaused = _p === void 0 ? false : _p, _q = _a.playbackRangeStart, playbackRangeStart = _q === void 0 ? null : _q, _r = _a.playbackRangeEnd, playbackRangeEnd = _r === void 0 ? null : _r, _s = _a.muted, muted = _s === void 0 ? true : _s, _t = _a.volume, volume = _t === void 0 ? 1 : _t, _u = _a.loop, loop = _u === void 0 ? true : _u, _v = _a.preload, preload = _v === void 0 ? null : _v, _w = _a.crossOrigin, crossOrigin = _w === void 0 ? 'anonymous' : _w, _x = _a.controls, controls = _x === void 0 ? false : _x, _y = _a.controlsList, controlsList = _y === void 0 ? null : _y, _z = _a.disableRemotePlayback, disableRemotePlayback = _z === void 0 ? true : _z, _0 = _a.disablePictureInPicture, disablePictureInPicture = _0 === void 0 ? true : _0, _1 = _a.className, className = _1 === void 0 ? null : _1, _2 = _a.style, style = _2 === void 0 ? null : _2, _3 = _a.hoverOverlayWrapperClassName, hoverOverlayWrapperClassName = _3 === void 0 ? null : _3, _4 = _a.hoverOverlayWrapperStyle, hoverOverlayWrapperStyle = _4 === void 0 ? null : _4, _5 = _a.pausedOverlayWrapperClassName, pausedOverlayWrapperClassName = _5 === void 0 ? null : _5, _6 = _a.pausedOverlayWrapperStyle, pausedOverlayWrapperStyle = _6 === void 0 ? null : _6, _7 = _a.loadingOverlayWrapperClassName, loadingOverlayWrapperClassName = _7 === void 0 ? null : _7, _8 = _a.loadingOverlayWrapperStyle, loadingOverlayWrapperStyle = _8 === void 0 ? null : _8, _9 = _a.videoId, videoId = _9 === void 0 ? null : _9, _10 = _a.videoClassName, videoClassName = _10 === void 0 ? null : _10, _11 = _a.videoRef, forwardedVideoRef = _11 === void 0 ? null : _11, _12 = _a.videoStyle, videoStyle = _12 === void 0 ? null : _12, _13 = _a.sizingMode, sizingMode = _13 === void 0 ? 'video' : _13;
    // Element refs
    var containerRef = React.useRef(null);
    var videoRef = React.useRef(null);
    // Forward out local videoRef along to the videoRef prop
    React.useImperativeHandle(forwardedVideoRef, function () { return videoRef.current; });
    // Effect sets attributes on the video which can't be done via props
    useSetAdditionalAttributesOnVideo(videoRef, muted, volume, disableRemotePlayback, disablePictureInPicture);
    var isHoveringOverVideo = useIsHoveringOverVideo(
    // If the hoverTarget prop wasn't provided, fall back to the component's container div
    hoverTarget || containerRef, disableDefaultEventHandling, onHoverStart, onHoverEnd);
    // We should attempt to play the video if the user is hovering over it or the `focused` override prop is enabled
    var shouldPlayVideo = isHoveringOverVideo || focused;
    var hasPausedOverlay = Boolean(pausedOverlay);
    var hasHoverOverlay = Boolean(hoverOverlay);
    // If we have a paused or hover overlay, the player should wait
    // for the overlay(s) to finish transitioning back in before we
    // pause the video
    var shouldWaitForOverlayTransitionBeforePausing = hasPausedOverlay || hasHoverOverlay;
    var hasLoadingOverlay = Boolean(loadingOverlay);
    // Effect handles transitioning the video between playing or paused states
    // depending on the current value for `shouldPlayVideo`
    var _14 = useManageVideoPlayback(videoRef, shouldPlayVideo, playbackRangeStart, playbackRangeEnd, loop, restartOnPaused, shouldWaitForOverlayTransitionBeforePausing, hasLoadingOverlay, overlayTransitionDuration, loadingStateTimeout), overlayState = _14[0], isVideoActive = _14[1];
    // If the video's sources should be unloaded when it's paused and the video is not currently active, we can unload the video's sources.
    // We will remove the video's <source> tags in this render and then call video.load() in an effect to
    // fully unload the video
    var shouldUnloadVideo = unloadVideoOnPaused && !isVideoActive;
    useUnloadVideo(videoRef, shouldUnloadVideo);
    // Parse the sources and captions into formatted arrays that we can use to
    // render <source> and <track> elements for the video
    var formattedVideoSources = useFormatVideoSrc(videoSrc, playbackRangeStart, playbackRangeEnd);
    var formattedVideoCaptions = useFormatVideoCaptions(videoCaptions);
    var hasPlaybackRange = playbackRangeStart !== null || playbackRangeEnd !== null;
    // Show the paused overlay if the overlay state is either "paused" OR "loading"; if
    // "loading", the loading overlay will be displayed on top of the paused overlay
    var isPausedOverlayVisible = overlayState !== OverlayState.playing;
    // Show the loading overlay only if the overlay state is specifically "loading"
    var isLoadingOverlayVisibile = overlayState === OverlayState.loading;
    return (React__default['default'].createElement("div", { "data-testid": "hover-video-player-container", ref: containerRef, className: className, style: __assign(__assign(__assign({}, containerSizingStyles[sizingMode]), { position: 'relative' }), style) },
        hasPausedOverlay ? (React__default['default'].createElement("div", { style: __assign(__assign(__assign({}, pausedOverlayWrapperSizingStyles[sizingMode]), { zIndex: 1, opacity: isPausedOverlayVisible ? 1 : 0, transition: "opacity " + overlayTransitionDuration + "ms", 
                // Disable pointer events on the paused overlay when it's hidden
                pointerEvents: isPausedOverlayVisible ? 'auto' : 'none' }), pausedOverlayWrapperStyle), className: pausedOverlayWrapperClassName, "data-testid": "paused-overlay-wrapper" }, pausedOverlay)) : null,
        hasLoadingOverlay ? (React__default['default'].createElement("div", { style: __assign(__assign(__assign({}, expandToFillContainerStyle), { zIndex: 2, opacity: isLoadingOverlayVisibile ? 1 : 0, transition: "opacity " + overlayTransitionDuration + "ms", 
                // Disable pointer events on the loading overlay when it's hidden
                pointerEvents: isLoadingOverlayVisibile ? 'auto' : 'none' }), loadingOverlayWrapperStyle), className: loadingOverlayWrapperClassName, "data-testid": "loading-overlay-wrapper" }, loadingOverlay)) : null,
        hasHoverOverlay ? (React__default['default'].createElement("div", { style: __assign(__assign(__assign({}, expandToFillContainerStyle), { zIndex: 3, 
                // Show the hover overlay when the player is hovered/playing
                opacity: shouldPlayVideo ? 1 : 0, transition: "opacity " + overlayTransitionDuration + "ms", 
                // Disable pointer events on the hover overlay when it's hidden
                pointerEvents: shouldPlayVideo ? 'auto' : 'none' }), hoverOverlayWrapperStyle), className: hoverOverlayWrapperClassName, "data-testid": "hover-overlay-wrapper" }, hoverOverlay)) : null,
        React__default['default'].createElement("video", { 
            // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;
            // in that case, we will manually implement this behavior
            loop: loop && !hasPlaybackRange, playsInline: true, preload: preload, crossOrigin: crossOrigin, ref: videoRef, style: __assign(__assign(__assign({}, videoSizingStyles[sizingMode]), { objectFit: 'cover' }), videoStyle), controls: controls, controlsList: controlsList, className: videoClassName, id: videoId, "data-testid": "video-element" },
            !shouldUnloadVideo &&
                // Only render sources for the video if it is not unloaded
                formattedVideoSources.map(function (_a) {
                    var src = _a.src, type = _a.type;
                    return (React__default['default'].createElement("source", { key: src, src: src, type: type }));
                }),
            formattedVideoCaptions.map(function (_a) {
                var src = _a.src, srcLang = _a.srcLang, label = _a.label, kind = _a.kind, isDefault = _a.default;
                return (React__default['default'].createElement("track", { key: src, kind: kind, src: src, srcLang: srcLang, label: label, default: isDefault }));
            }))));
};

module.exports = HoverVideoPlayer;
//# sourceMappingURL=index.js.map
